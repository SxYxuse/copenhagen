import{d as g,a as r,t as n,f as h,b as e,c as V}from"./disclose-version.Bedei8AD.js";import{h as y}from"./index.DWgPtC_I.js";import{B as oe,H as ie,P as o}from"./blueprint.CLPDHYwR.js";import{H as f}from"./h2.BLVNhL6Q.js";import{U as de,L as m}from"./ul.5IqOVinl.js";import{A as v}from"./a.CxCmjLdc.js";import{H as z}from"./h3.BZHhAxYy.js";import{P as Z}from"./pre.DAToQk2m.js";var le=n("Multi-factor authentication (MFA)",1),pe=n("Overview",1),ue=n("MFA is when a user is required to input more than just a password to authenticate. There are mainly 5 types of factors:",1),_e=n("Something you know: Passwords",1),he=n("Something you have: Device, email address, SMS",1),ce=n("Something you are: Biometrics",1),fe=n("Somewhere you are",1),me=n("Something you do",1),ve=n("<!> <!> <!> <!> <!>",1),$e=n("Time-based one-time passwords (TOTP)",1),ge=n("RFC 6238",1),ye=n("RFC 4226",1),Se=n("TOTP is defined in <!>, which is based on hash-based one-time passwords (HOTP), defined in <!>.",1),Pe=n("Standard TOTP uses an authenticator app, usually installed on the user's mobile device, to generate a code for the user.",1),Me=n("Each user has a secret key. This is shared with the user's authenticator app with a QR code. Using that secret and the current time, the authenticator app can generate a new OTP. Your app asks for the current OTP and it can validate it by generating one using the same parameters. Since the current time is used to generate the code, each code is only valid for a set period (usually 30 seconds).",1),be=n("Generate QR code",1),we=n("HMAC SHA-1 is used to generate TOTPs. The secret key is exactly 160 bits and it must be generated using a cryptographically-secure random generator. Each user must have its own secret and the secret should be stored in your server. The secret can be encrypted before storage if you're worried about accidentally leaking your database records. It's important to remember that encrypting data won't protect against attackers who have system-level access to your servers however.",1),Te=n("key URI",1),De=n("To share the secret, generate a <!> and encode it into a QR code. The <!> is base32 encoded.",1),Ce=n("You should verify that the user has correctly scanned the QR code by asking for the generated OTP.",1),Xe=n("When a user requests for a new QR code, generate a new secret and invalidate the previous one.",1),ke=n("Validate OTPs",1),He=n("To validate a TOTP, we need to generate one first.",1),Oe=n("HOTPs are generated by signing a counter value with HMAC. In HOTP, the counter is an integer that is incremented whenever a new code is generated. But in TOTP, the counter is the current UNIX time divided by the interval (usually 30 seconds) with the fractional part truncated.",1),xe=n("The counter, which should be 8 bytes, is hashed with HMAC SHA-1. 4 bytes are extracted using an offset. Then the last 31 bits is extracted and converted into an integer. Finally, the last 6 digit is used as the OTP.",1),Ae=n("To validate an OTP, you can simply generate one on your end and check if it matches with what the user provided.",1),Ue=n("Throttling must be implemented. A basic example is blocking attempts for 15 to 60 minutes after the 5th consecutive failed attempt. The user should also be notified to change the password as well.",1),Fe=n("SMS",1),Re=n("Email verification code",1),Be=n("We discourage SMS based MFA as it can be intercepted and unreliable at times. However, it may be more accessible than using authenticator apps. See the <!> guide for a guideline on implementing verification codes. The code should be valid for around 5 minutes.",1),Ee=n("Throttling must be implemented. A basic example is blocking attempts for 15 to 60 minutes after the 5th consecutive failed attempt. The user should also be notified to change the password as well.",1),Ie=n("Passkeys",1),Qe=n("Passkeys",1),Ne=n("Passkeys allow you to use in-device authentication methods, such as biometrics and pin-codes. See the <!> guide.",1),We=n("Recovery codes",1),qe=n("If your application uses MFA, we recommend issuing users with 1 or more recovery codes. These are single-use passwords that can be used instead of passkeys/OTPs to sign in and reset their second-factor when a user loses access to their devices. The codes must be generated using a cryptographically-secure random generator. They can be generated with only 40 bits of entropy (10 characters when encoded with hex) assuming proper throttling is implemented.",1),Ye=n("Unless you can securely store these codes, we recommend hashing them with your preferred password hashing algorithm (e.g. Argon2id). In this case, the codes are only visible the first time the user registers their second-factor. User should also be given the option to regenerate them if they have access to their second-factor.",1),Je=n('<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <figure data-rehype-pretty-code-figure=""><!></figure> <!> <!> <!> <!> <!> <figure data-rehype-pretty-code-figure=""><!></figure> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!>',1);const Ke={title:"Multi-factor authentication (MFA)"};function rt(ee){var S=g(),te=h(S);oe(te,{metadata:Ke,children:(ae,Le)=>{var P=Je(),M=h(P);ie(M,{id:"multi-factor-authentication-mfa",children:(a,s)=>{var t=le();r(a,t)},$$slots:{default:!0}});var b=e(e(M,!0));f(b,{id:"overview",children:(a,s)=>{var t=pe();r(a,t)},$$slots:{default:!0}});var w=e(e(b,!0));o(w,{children:(a,s)=>{var t=ue();r(a,t)},$$slots:{default:!0}});var T=e(e(w,!0));de(T,{children:(a,s)=>{var t=ve(),i=h(t);m(i,{children:(u,$)=>{var _=_e();r(u,_)},$$slots:{default:!0}});var d=e(e(i,!0));m(d,{children:(u,$)=>{var _=he();r(u,_)},$$slots:{default:!0}});var l=e(e(d,!0));m(l,{children:(u,$)=>{var _=ce();r(u,_)},$$slots:{default:!0}});var p=e(e(l,!0));m(p,{children:(u,$)=>{var _=fe();r(u,_)},$$slots:{default:!0}});var c=e(e(p,!0));m(c,{children:(u,$)=>{var _=me();r(u,_)},$$slots:{default:!0}}),r(a,t)},$$slots:{default:!0}});var D=e(e(T,!0));f(D,{id:"time-based-one-time-passwords-totp",children:(a,s)=>{var t=$e();r(a,t)},$$slots:{default:!0}});var C=e(e(D,!0));o(C,{children:(a,s)=>{var t=Se(),i=e(h(t,!0));v(i,{href:"https://datatracker.ietf.org/doc/html/rfc6238",children:(l,p)=>{var c=ge();r(l,c)},$$slots:{default:!0}});var d=e(e(i,!0));v(d,{href:"https://www.ietf.org/rfc/rfc4226.txt",children:(l,p)=>{var c=ye();r(l,c)},$$slots:{default:!0}}),r(a,t)},$$slots:{default:!0}});var X=e(e(C,!0));o(X,{children:(a,s)=>{var t=Pe();r(a,t)},$$slots:{default:!0}});var k=e(e(X,!0));o(k,{children:(a,s)=>{var t=Me();r(a,t)},$$slots:{default:!0}});var H=e(e(k,!0));z(H,{id:"generate-qr-code",children:(a,s)=>{var t=be();r(a,t)},$$slots:{default:!0}});var O=e(e(H,!0));o(O,{children:(a,s)=>{var t=we();r(a,t)},$$slots:{default:!0}});var x=e(e(O,!0));o(x,{children:(a,s)=>{var t=De(),i=e(h(t,!0));v(i,{href:"https://github.com/google/google-authenticator/wiki/Key-Uri-Format",children:(l,p)=>{var c=Te();r(l,c)},$$slots:{default:!0}});var d=e(e(i,!0));y(d,()=>"<code>secret</code>"),r(a,t)},$$slots:{default:!0}});var A=e(e(x,!0));o(A,{children:(a,s)=>{var t=Ce();r(a,t)},$$slots:{default:!0}});var U=e(e(A,!0)),re=V(U);Z(re,{class:"Serendipity Midnight Serendipity Morning",tabindex:"0","data-language":"untype","data-theme":"Serendipity Midnight Serendipity Morning",children:(a,s)=>{var t=g(),i=h(t);y(i,()=>'<code data-language="untype" data-theme="Serendipity Midnight Serendipity Morning" style="display: grid;"><span data-line=""><span>otpauth://totp/example%20app:John%20Doe?secret=JBSWY3DPEHPK3PXP&amp;issuer=Example%20App&amp;digits=6&amp;period=30</span></span></code>'),r(a,t)},$$slots:{default:!0}});var F=e(e(U,!0));o(F,{children:(a,s)=>{var t=Xe();r(a,t)},$$slots:{default:!0}});var R=e(e(F,!0));z(R,{id:"validate-otps",children:(a,s)=>{var t=ke();r(a,t)},$$slots:{default:!0}});var B=e(e(R,!0));o(B,{children:(a,s)=>{var t=He();r(a,t)},$$slots:{default:!0}});var E=e(e(B,!0));o(E,{children:(a,s)=>{var t=Oe();r(a,t)},$$slots:{default:!0}});var I=e(e(E,!0));o(I,{children:(a,s)=>{var t=xe();r(a,t)},$$slots:{default:!0}});var Q=e(e(I,!0)),ne=V(Q);Z(ne,{class:"Serendipity Midnight Serendipity Morning",tabindex:"0","data-language":"untype","data-theme":"Serendipity Midnight Serendipity Morning",children:(a,s)=>{var t=g(),i=h(t);y(i,()=>`<code data-language="untype" data-theme="Serendipity Midnight Serendipity Morning" style="display: grid;"><span data-line=""><span>import (</span></span>
<span data-line=""><span>	"crypto/hmac"</span></span>
<span data-line=""><span>	"crypto/sha1"</span></span>
<span data-line=""><span>	"encoding/binary"</span></span>
<span data-line=""><span>	"fmt"</span></span>
<span data-line=""><span>	"math"</span></span>
<span data-line=""><span>)</span></span>
<span data-line=""> </span>
<span data-line=""><span>func generateTOTP(secret []byte) &#123;</span></span>
<span data-line=""><span>	digits := 6</span></span>
<span data-line=""><span>	counter := time.Now().Unix() / 30</span></span>
<span data-line=""> </span>
<span data-line=""><span>	// HOTP</span></span>
<span data-line=""><span>	mac := hmac.New(sha1.New, secret)</span></span>
<span data-line=""><span>	buf := make([]byte, 8)</span></span>
<span data-line=""><span>	binary.BigEndian.PutUint64(buf, uint64(counter))</span></span>
<span data-line=""><span>	mac.Write(buf)</span></span>
<span data-line=""><span>	HS := mac.Sum(nil)</span></span>
<span data-line=""><span>	offset := HS[19] &amp; 0x0f</span></span>
<span data-line=""><span>	Snum := binary.BigEndian.Uint32(HS[offset:offset+4]) &amp; 0x7fffffff</span></span>
<span data-line=""><span>	D := Snum % int(math.Pow(10, float64(digits)))</span></span>
<span data-line=""><span>	// Pad "0" to make it 6 digits.</span></span>
<span data-line=""><span>	return fmt.Sprintf("%06d", D)</span></span>
<span data-line=""><span>&#125;</span></span></code>`),r(a,t)},$$slots:{default:!0}});var N=e(e(Q,!0));o(N,{children:(a,s)=>{var t=Ae();r(a,t)},$$slots:{default:!0}});var W=e(e(N,!0));o(W,{children:(a,s)=>{var t=Ue();r(a,t)},$$slots:{default:!0}});var q=e(e(W,!0));f(q,{id:"sms",children:(a,s)=>{var t=Fe();r(a,t)},$$slots:{default:!0}});var Y=e(e(q,!0));o(Y,{children:(a,s)=>{var t=Be(),i=e(h(t,!0));v(i,{href:"/content/email-verification#email-verification-codes",children:(d,l)=>{var p=Re();r(d,p)},$$slots:{default:!0}}),r(a,t)},$$slots:{default:!0}});var J=e(e(Y,!0));o(J,{children:(a,s)=>{var t=Ee();r(a,t)},$$slots:{default:!0}});var K=e(e(J,!0));f(K,{id:"passkeys",children:(a,s)=>{var t=Ie();r(a,t)},$$slots:{default:!0}});var L=e(e(K,!0));o(L,{children:(a,s)=>{var t=Ne(),i=e(h(t,!0));v(i,{href:"/content/passkeys",children:(d,l)=>{var p=Qe();r(d,p)},$$slots:{default:!0}}),r(a,t)},$$slots:{default:!0}});var j=e(e(L,!0));f(j,{id:"recovery-codes",children:(a,s)=>{var t=We();r(a,t)},$$slots:{default:!0}});var G=e(e(j,!0));o(G,{children:(a,s)=>{var t=qe();r(a,t)},$$slots:{default:!0}});var se=e(e(G,!0));o(se,{children:(a,s)=>{var t=Ye();r(a,t)},$$slots:{default:!0}}),r(ae,P)},$$slots:{default:!0}}),r(ee,S)}export{rt as default,Ke as metadata};
